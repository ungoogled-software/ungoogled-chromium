--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -625,7 +625,6 @@ class CertificateReportingServiceCertRep
   // SSLCertReporter implementation
   void ReportInvalidCertificateChain(
       const std::string& serialized_report) override {
-    service_->Send(serialized_report);
   }
 
  private:
@@ -1635,7 +1634,7 @@ void ChromeContentBrowserClient::AppendE
       // Disable client-side phishing detection in the renderer if it is
       // disabled in the Profile preferences or the browser process.
       if (!prefs->GetBoolean(prefs::kSafeBrowsingEnabled) ||
-          !g_browser_process->safe_browsing_detection_service()) {
+          true) {
         command_line->AppendSwitch(
             switches::kDisableClientSidePhishingDetection);
       }
@@ -2162,15 +2161,9 @@ void ChromeContentBrowserClient::AllowCe
   if (expired_previous_decision)
     options_mask |= SSLErrorUI::EXPIRED_BUT_PREVIOUSLY_ALLOWED;
 
-  CertificateReportingService* cert_reporting_service =
-      CertificateReportingServiceFactory::GetForBrowserContext(
-          web_contents->GetBrowserContext());
-  std::unique_ptr<CertificateReportingServiceCertReporter> cert_reporter(
-      new CertificateReportingServiceCertReporter(cert_reporting_service));
-
   SSLErrorHandler::HandleSSLError(web_contents, cert_error, ssl_info,
                                   request_url, options_mask,
-                                  std::move(cert_reporter), callback);
+                                  nullptr, callback);
 }
 
 void ChromeContentBrowserClient::SelectClientCertificate(
@@ -2359,8 +2352,6 @@ bool ChromeContentBrowserClient::CanCrea
 void ChromeContentBrowserClient::ResourceDispatcherHostCreated() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
-  safe_browsing_service_ = g_browser_process->safe_browsing_service();
-
   for (size_t i = 0; i < extra_parts_.size(); ++i)
     extra_parts_[i]->ResourceDispatcherHostCreated();
 
@@ -2875,17 +2866,6 @@ void ChromeContentBrowserClient::ExposeI
                                       base::RetainedRef(context)));
   }
 
-  if (safe_browsing_service_) {
-    registry->AddInterface(
-        base::Bind(
-            &safe_browsing::MojoSafeBrowsingImpl::MaybeCreate,
-            render_process_host->GetID(),
-            base::Bind(
-                &ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate,
-                base::Unretained(this))),
-        BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));
-  }
-
 #if defined(OS_WIN)
   if (base::FeatureList::IsEnabled(features::kModuleDatabase)) {
     // Add the ModuleEventSink interface. This is the interface used by renderer
@@ -3417,12 +3397,6 @@ ChromeContentBrowserClient::CreateURLLoa
 
   std::vector<std::unique_ptr<content::URLLoaderThrottle>> result;
 
-  auto safe_browsing_throttle =
-      safe_browsing::BrowserURLLoaderThrottle::MaybeCreate(
-          GetSafeBrowsingUrlCheckerDelegate(), wc_getter);
-  if (safe_browsing_throttle)
-    result.push_back(std::move(safe_browsing_throttle));
-
   return result;
 }
 
@@ -3496,18 +3470,3 @@ void ChromeContentBrowserClient::SetDefa
     const storage::QuotaSettings* settings) {
   g_default_quota_settings = settings;
 }
-
-safe_browsing::UrlCheckerDelegate*
-ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate() {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  // |safe_browsing_service_| may be unavailable in tests.
-  if (safe_browsing_service_ && !safe_browsing_url_checker_delegate_) {
-    safe_browsing_url_checker_delegate_ =
-        new safe_browsing::UrlCheckerDelegateImpl(
-            safe_browsing_service_->database_manager(),
-            safe_browsing_service_->ui_manager());
-  }
-
-  return safe_browsing_url_checker_delegate_.get();
-}
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -492,18 +492,6 @@ ProfileImpl::ProfileImpl(
                                  create_mode == CREATE_MODE_SYNCHRONOUS);
 #endif
 
-  scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service(
-      g_browser_process->safe_browsing_service());
-  prefs::mojom::TrackedPreferenceValidationDelegatePtr pref_validation_delegate;
-  if (safe_browsing_service.get()) {
-    auto pref_validation_delegate_impl =
-        safe_browsing_service->CreatePreferenceValidationDelegate(this);
-    if (pref_validation_delegate_impl) {
-      mojo::MakeStrongBinding(std::move(pref_validation_delegate_impl),
-                              mojo::MakeRequest(&pref_validation_delegate));
-    }
-  }
-
   content::BrowserContext::Initialize(this, path_);
 
   {
@@ -512,7 +500,7 @@ ProfileImpl::ProfileImpl(
             ->CreateDelegate();
     delegate->InitPrefRegistry(pref_registry_.get());
     prefs_ = chrome_prefs::CreateProfilePrefs(
-        path_, std::move(pref_validation_delegate),
+        path_, nullptr,
         profile_policy_connector_->policy_service(), supervised_user_settings,
         CreateExtensionPrefStore(this, false), pref_registry_, async_prefs,
         GetIOTaskRunner(), std::move(delegate));
--- a/chrome/browser/loader/chrome_resource_dispatcher_host_delegate.cc
+++ b/chrome/browser/loader/chrome_resource_dispatcher_host_delegate.cc
@@ -468,8 +468,7 @@ void NotifyUIThreadOfRequestComplete(
 }  // namespace
 
 ChromeResourceDispatcherHostDelegate::ChromeResourceDispatcherHostDelegate()
-    : download_request_limiter_(g_browser_process->download_request_limiter()),
-      safe_browsing_(g_browser_process->safe_browsing_service())
+    : download_request_limiter_(g_browser_process->download_request_limiter())
 #if BUILDFLAG(ENABLE_EXTENSIONS)
       , user_script_listener_(new extensions::UserScriptListener())
 #endif
@@ -519,9 +518,6 @@ void ChromeResourceDispatcherHostDelegat
     content::AppCacheService* appcache_service,
     ResourceType resource_type,
     std::vector<std::unique_ptr<content::ResourceThrottle>>* throttles) {
-  if (safe_browsing_.get())
-    safe_browsing_->OnResourceRequest(request);
-
   const ResourceRequestInfo* info = ResourceRequestInfo::ForRequest(request);
 
 #if BUILDFLAG(ENABLE_OFFLINE_PAGES)
@@ -707,13 +703,13 @@ void ChromeResourceDispatcherHostDelegat
   content::ResourceThrottle* first_throttle = NULL;
 #if defined(OS_ANDROID)
   first_throttle = DataReductionProxyResourceThrottle::MaybeCreate(
-      request, resource_context, resource_type, safe_browsing_.get());
+      request, resource_context, resource_type, nullptr);
 #endif  // defined(OS_ANDROID)
 
 #if defined(SAFE_BROWSING_DB_LOCAL) || defined(SAFE_BROWSING_DB_REMOTE)
   if (!first_throttle && io_data->safe_browsing_enabled()->GetValue()) {
     first_throttle = MaybeCreateSafeBrowsingResourceThrottle(
-        request, resource_type, safe_browsing_.get());
+        request, resource_type, nullptr);
   }
 #endif  // defined(SAFE_BROWSING_DB_LOCAL) || defined(SAFE_BROWSING_DB_REMOTE)
 
--- a/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
+++ b/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
@@ -244,7 +244,7 @@ BadClockBlockingPage* CreateBadClockBloc
       clock_state, nullptr,
       base::Callback<void(content::CertificateRequestResultType)>());
 }
-
+#if 0
 safe_browsing::SafeBrowsingBlockingPage* CreateSafeBrowsingBlockingPage(
     content::WebContents* web_contents) {
   safe_browsing::SBThreatType threat_type =
@@ -298,52 +298,7 @@ safe_browsing::SafeBrowsingBlockingPage*
       g_browser_process->safe_browsing_service()->ui_manager().get(),
       web_contents, main_frame_url, resource);
 }
-
-TestSafeBrowsingBlockingPageQuiet* CreateSafeBrowsingQuietBlockingPage(
-    content::WebContents* web_contents) {
-  safe_browsing::SBThreatType threat_type =
-      safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-  GURL request_url("http://example.com");
-  std::string url_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "url", &url_param)) {
-    if (GURL(url_param).is_valid())
-      request_url = GURL(url_param);
-  }
-  GURL main_frame_url(request_url);
-  std::string type_param;
-  bool is_giant_webview = false;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "type", &type_param)) {
-    if (type_param == "malware") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-    } else if (type_param == "phishing") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_PHISHING;
-    } else if (type_param == "giant") {
-      threat_type = safe_browsing::SB_THREAT_TYPE_URL_MALWARE;
-      is_giant_webview = true;
-    }
-  }
-  safe_browsing::SafeBrowsingBlockingPage::UnsafeResource resource;
-  resource.url = request_url;
-  resource.is_subresource = request_url != main_frame_url;
-  resource.is_subframe = false;
-  resource.threat_type = threat_type;
-  resource.web_contents_getter =
-      security_interstitials::UnsafeResource::GetWebContentsGetter(
-          web_contents->GetRenderProcessHost()->GetID(),
-          web_contents->GetMainFrame()->GetRoutingID());
-  resource.threat_source = safe_browsing::ThreatSource::LOCAL_PVER3;
-
-  // Normally safebrowsing interstitial types which block the main page load
-  // (SB_THREAT_TYPE_URL_MALWARE, SB_THREAT_TYPE_URL_PHISHING, and
-  // SB_THREAT_TYPE_URL_UNWANTED on main-frame loads) would expect there to be a
-  // pending navigation when the SafeBrowsingBlockingPage is created. This demo
-  // creates a SafeBrowsingBlockingPage but does not actually show a real
-  // interstitial. Instead it extracts the html and displays it manually, so the
-  // parts which depend on the NavigationEntry are not hit.
-  return TestSafeBrowsingBlockingPageQuiet::CreateBlockingPage(
-      g_browser_process->safe_browsing_service()->ui_manager().get(),
-      web_contents, main_frame_url, resource, is_giant_webview);
-}
+#endif
 
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
 CaptivePortalBlockingPage* CreateCaptivePortalBlockingPage(
@@ -445,9 +400,6 @@ void InterstitialHTMLSource::StartDataRe
   } else if (base::StartsWith(path, "mitm-software-ssl",
                               base::CompareCase::SENSITIVE)) {
     interstitial_delegate.reset(CreateMITMSoftwareBlockingPage(web_contents));
-  } else if (base::StartsWith(path, "safebrowsing",
-                              base::CompareCase::SENSITIVE)) {
-    interstitial_delegate.reset(CreateSafeBrowsingBlockingPage(web_contents));
   } else if (base::StartsWith(path, "clock", base::CompareCase::SENSITIVE)) {
     interstitial_delegate.reset(CreateBadClockBlockingPage(web_contents));
   }
@@ -460,12 +412,6 @@ void InterstitialHTMLSource::StartDataRe
 #endif
   if (base::StartsWith(path, "supervised_user", base::CompareCase::SENSITIVE)) {
     html = GetSupervisedUserInterstitialHTML(path);
-  } else if (base::StartsWith(path, "quietsafebrowsing",
-                              base::CompareCase::SENSITIVE)) {
-    TestSafeBrowsingBlockingPageQuiet* blocking_page =
-        CreateSafeBrowsingQuietBlockingPage(web_contents);
-    interstitial_delegate.reset(blocking_page);
-    html = blocking_page->GetHTML();
   } else if (interstitial_delegate.get()) {
     html = interstitial_delegate.get()->GetHTMLContents();
   } else {
--- a/chrome/browser/extensions/blacklist_state_fetcher.cc
+++ b/chrome/browser/extensions/blacklist_state_fetcher.cc
@@ -32,10 +32,10 @@ BlacklistStateFetcher::~BlacklistStateFe
 void BlacklistStateFetcher::Request(const std::string& id,
                                     const RequestCallback& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!safe_browsing_config_) {
-    if (g_browser_process && g_browser_process->safe_browsing_service()) {
-      SetSafeBrowsingConfig(
-          g_browser_process->safe_browsing_service()->GetProtocolConfig());
+  if (true) {
+    if (false) {
+      //SetSafeBrowsingConfig(
+      //    g_browser_process->safe_browsing_service()->GetProtocolConfig());
     } else {
       base::ThreadTaskRunnerHandle::Get()->PostTask(
           FROM_HERE, base::BindOnce(callback, BLACKLISTED_UNKNOWN));
@@ -48,11 +48,11 @@ void BlacklistStateFetcher::Request(cons
   if (request_already_sent)
     return;
 
-  if (!url_request_context_getter_ && g_browser_process &&
-      g_browser_process->safe_browsing_service()) {
-    url_request_context_getter_ =
-        g_browser_process->safe_browsing_service()->url_request_context();
-  }
+  //if (!url_request_context_getter_ && g_browser_process &&
+  //    g_browser_process->safe_browsing_service()) {
+  //  url_request_context_getter_ =
+  //      g_browser_process->safe_browsing_service()->url_request_context();
+  //}
 
   SendRequest(id);
 }
@@ -108,11 +108,11 @@ void BlacklistStateFetcher::SendRequest(
   fetcher->Start();
 }
 
-void BlacklistStateFetcher::SetSafeBrowsingConfig(
-    const safe_browsing::SafeBrowsingProtocolConfig& config) {
-  safe_browsing_config_.reset(
-      new safe_browsing::SafeBrowsingProtocolConfig(config));
-}
+//void BlacklistStateFetcher::SetSafeBrowsingConfig(
+//    const safe_browsing::SafeBrowsingProtocolConfig& config) {
+//  safe_browsing_config_.reset(
+//      new safe_browsing::SafeBrowsingProtocolConfig(config));
+//}
 
 void BlacklistStateFetcher::SetURLRequestContextForTest(
       net::URLRequestContextGetter* request_context) {
@@ -120,6 +120,7 @@ void BlacklistStateFetcher::SetURLReques
 }
 
 GURL BlacklistStateFetcher::RequestUrl() const {
+  /*
   std::string url = base::StringPrintf(
       "%s/%s?client=%s&appver=%s&pver=2.2",
       safe_browsing_config_->url_prefix.c_str(),
@@ -132,6 +133,8 @@ GURL BlacklistStateFetcher::RequestUrl()
                         net::EscapeQueryParamValue(api_key, true).c_str());
   }
   return GURL(url);
+  */
+  return GURL();
 }
 
 void BlacklistStateFetcher::OnURLFetchComplete(const net::URLFetcher* source) {
--- a/chrome/browser/extensions/blacklist_state_fetcher.h
+++ b/chrome/browser/extensions/blacklist_state_fetcher.h
@@ -34,8 +34,8 @@ class BlacklistStateFetcher : public net
 
   virtual void Request(const std::string& id, const RequestCallback& callback);
 
-  void SetSafeBrowsingConfig(
-      const safe_browsing::SafeBrowsingProtocolConfig& config);
+  //void SetSafeBrowsingConfig(
+  //    const safe_browsing::SafeBrowsingProtocolConfig& config);
 
   void SetURLRequestContextForTest(
       net::URLRequestContextGetter* request_context);
@@ -54,8 +54,8 @@ class BlacklistStateFetcher : public net
   // ID for URLFetchers for testing.
   int url_fetcher_id_;
 
-  std::unique_ptr<safe_browsing::SafeBrowsingProtocolConfig>
-      safe_browsing_config_;
+  //std::unique_ptr<safe_browsing::SafeBrowsingProtocolConfig>
+  //    safe_browsing_config_;
   scoped_refptr<net::URLRequestContextGetter> url_request_context_getter_;
   scoped_refptr<net::URLRequestContextGetter> parent_request_context_for_test_;
 
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -228,13 +228,6 @@ ChromeDownloadManagerDelegate::~ChromeDo
 
 void ChromeDownloadManagerDelegate::SetDownloadManager(DownloadManager* dm) {
   download_manager_ = dm;
-
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (sb_service && !profile_->IsOffTheRecord()) {
-    // Include this download manager in the set monitored by safe browsing.
-    sb_service->AddDownloadManager(dm);
-  }
 }
 
 void ChromeDownloadManagerDelegate::Shutdown() {
@@ -498,16 +491,6 @@ void ChromeDownloadManagerDelegate::Choo
 
 void ChromeDownloadManagerDelegate::SanitizeSavePackageResourceName(
     base::FilePath* filename) {
-  safe_browsing::FileTypePolicies* file_type_policies =
-      safe_browsing::FileTypePolicies::GetInstance();
-
-  if (file_type_policies->GetFileDangerLevel(*filename) ==
-      safe_browsing::DownloadFileType::NOT_DANGEROUS)
-    return;
-
-  base::FilePath default_filename = base::FilePath::FromUTF8Unsafe(
-      l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME));
-  *filename = filename->AddExtension(default_filename.BaseName().value());
 }
 
 void ChromeDownloadManagerDelegate::OpenDownloadUsingPlatformHandler(
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -70,7 +70,6 @@
 #include "chrome/browser/printing/print_job_manager.h"
 #include "chrome/browser/printing/print_preview_dialog_controller.h"
 #include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/browser/shell_integration.h"
 #include "chrome/browser/status_icons/status_tray.h"
 #include "chrome/browser/ui/browser_dialogs.h"
@@ -221,7 +220,6 @@ BrowserProcessImpl::BrowserProcessImpl(
       created_icon_manager_(false),
       created_notification_ui_manager_(false),
       created_notification_bridge_(false),
-      created_safe_browsing_service_(false),
       created_subresource_filter_ruleset_service_(false),
       shutting_down_(false),
       tearing_down_(false),
@@ -312,8 +310,6 @@ void BrowserProcessImpl::StartTearDown()
   // that URLFetcher operation before going away.)
   metrics_services_manager_.reset();
   intranet_redirect_detector_.reset();
-  if (safe_browsing_service_.get())
-    safe_browsing_service()->ShutDown();
   network_time_tracker_.reset();
 #if BUILDFLAG(ENABLE_PLUGINS)
   plugins_resource_service_.reset();
@@ -917,22 +913,6 @@ StatusTray* BrowserProcessImpl::status_t
   return status_tray_.get();
 }
 
-safe_browsing::SafeBrowsingService*
-BrowserProcessImpl::safe_browsing_service() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (!created_safe_browsing_service_)
-    CreateSafeBrowsingService();
-  return safe_browsing_service_.get();
-}
-
-safe_browsing::ClientSideDetectionService*
-    BrowserProcessImpl::safe_browsing_detection_service() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (safe_browsing_service())
-    return safe_browsing_service()->safe_browsing_detection_service();
-  return NULL;
-}
-
 subresource_filter::ContentRulesetService*
 BrowserProcessImpl::subresource_filter_ruleset_service() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -1220,16 +1200,6 @@ void BrowserProcessImpl::CreateBackgroun
 #endif
 }
 
-void BrowserProcessImpl::CreateSafeBrowsingService() {
-  DCHECK(!safe_browsing_service_);
-  // Set this flag to true so that we don't retry indefinitely to
-  // create the service class if there was an error.
-  created_safe_browsing_service_ = true;
-  safe_browsing_service_ =
-      safe_browsing::SafeBrowsingService::CreateSafeBrowsingService();
-  safe_browsing_service_->Initialize();
-}
-
 void BrowserProcessImpl::CreateSubresourceFilterRulesetService() {
   DCHECK(!subresource_filter_ruleset_service_);
   created_subresource_filter_ruleset_service_ = true;
--- a/chrome/browser/browser_process_impl.h
+++ b/chrome/browser/browser_process_impl.h
@@ -132,9 +132,6 @@ class BrowserProcessImpl : public Browse
   void set_background_mode_manager_for_test(
       std::unique_ptr<BackgroundModeManager> manager) override;
   StatusTray* status_tray() override;
-  safe_browsing::SafeBrowsingService* safe_browsing_service() override;
-  safe_browsing::ClientSideDetectionService* safe_browsing_detection_service()
-      override;
   subresource_filter::ContentRulesetService*
   subresource_filter_ruleset_service() override;
 
@@ -264,9 +261,6 @@ class BrowserProcessImpl : public Browse
   std::unique_ptr<BackgroundModeManager> background_mode_manager_;
 #endif
 
-  bool created_safe_browsing_service_;
-  scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service_;
-
   bool created_subresource_filter_ruleset_service_;
   std::unique_ptr<subresource_filter::ContentRulesetService>
       subresource_filter_ruleset_service_;
--- a/chrome/browser/browser_process.h
+++ b/chrome/browser/browser_process.h
@@ -43,10 +43,6 @@ class WatchDogThread;
 class WebRtcLogUploader;
 #endif
 
-namespace safe_browsing {
-class SafeBrowsingService;
-}
-
 namespace subresource_filter {
 class ContentRulesetService;
 }
@@ -120,10 +116,6 @@ namespace resource_coordinator {
 class TabManager;
 }
 
-namespace safe_browsing {
-class ClientSideDetectionService;
-}
-
 namespace ukm {
 class UkmRecorder;
 }
@@ -245,14 +237,6 @@ class BrowserProcess {
   // on this platform (or this is a unit test).
   virtual StatusTray* status_tray() = 0;
 
-  // Returns the SafeBrowsing service.
-  virtual safe_browsing::SafeBrowsingService* safe_browsing_service() = 0;
-
-  // Returns an object which handles communication with the SafeBrowsing
-  // client-side detection servers.
-  virtual safe_browsing::ClientSideDetectionService*
-      safe_browsing_detection_service() = 0;
-
   // Returns the service providing versioned storage for rules used by the Safe
   // Browsing subresource filter.
   virtual subresource_filter::ContentRulesetService*
--- a/chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.h
+++ b/chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.h
@@ -12,7 +12,6 @@
 
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/ui/webui/md_downloads/downloads_list_tracker.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_ui_message_handler.h"
@@ -104,9 +103,6 @@ class MdDownloadsDOMHandler : public con
   // dangerous ones are immediately removed. Protected for testing.
   void RemoveDownloads(const DownloadVector& to_remove);
 
-  // Helper function to handle save download event.
-  void SaveDownload(content::DownloadItem* download);
-
  private:
   using IdSet = std::set<uint32_t>;
 
@@ -118,19 +114,6 @@ class MdDownloadsDOMHandler : public con
   // null-checking |original_notifier_|.
   content::DownloadManager* GetOriginalNotifierManager() const;
 
-  // Displays a native prompt asking the user for confirmation after accepting
-  // the dangerous download specified by |dangerous|. The function returns
-  // immediately, and will invoke DangerPromptAccepted() asynchronously if the
-  // user accepts the dangerous download. The native prompt will observe
-  // |dangerous| until either the dialog is dismissed or |dangerous| is no
-  // longer an in-progress dangerous download.
-  virtual void ShowDangerPrompt(content::DownloadItem* dangerous);
-
-  // Conveys danger acceptance from the DownloadDangerPrompt to the
-  // DownloadItem.
-  virtual void DangerPromptDone(int download_id,
-                                DownloadDangerPrompt::Action action);
-
   // Returns true if the records of any downloaded items are allowed (and able)
   // to be deleted.
   bool IsDeletingHistoryAllowed();
--- a/chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.cc
+++ b/chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.cc
@@ -20,7 +20,6 @@
 #include "base/threading/thread.h"
 #include "base/values.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_history.h"
 #include "chrome/browser/download/download_item_model.h"
 #include "chrome/browser/download/download_prefs.h"
@@ -194,34 +193,6 @@ void MdDownloadsDOMHandler::HandleDrag(c
 
 void MdDownloadsDOMHandler::HandleSaveDangerous(const base::ListValue* args) {
   CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_SAVE_DANGEROUS);
-  content::DownloadItem* file = GetDownloadByValue(args);
-  SaveDownload(file);
-}
-
-void MdDownloadsDOMHandler::SaveDownload(
-    content::DownloadItem* download) {
-  if (!download)
-    return;
-  // If danger type is NOT DANGEROUS_FILE, chrome shows users a download danger
-  // prompt.
-  if (download->GetDangerType() !=
-      content::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE) {
-    ShowDangerPrompt(download);
-  } else {
-    // If danger type is DANGEROUS_FILE, chrome proceeds to keep this download
-    // without showing download danger prompt.
-    if (profile_) {
-      PrefService* prefs = profile_->GetPrefs();
-      if (!profile_->IsOffTheRecord() &&
-          prefs->GetBoolean(prefs::kSafeBrowsingEnabled)) {
-        DownloadDangerPrompt::SendSafeBrowsingDownloadReport(
-            safe_browsing::ClientSafeBrowsingReportRequest::
-                DANGEROUS_DOWNLOAD_RECOVERY,
-            true, *download);
-      }
-    }
-    DangerPromptDone(download->GetId(), DownloadDangerPrompt::ACCEPT);
-  }
 }
 
 void MdDownloadsDOMHandler::HandleDiscardDangerous(
@@ -323,12 +294,6 @@ void MdDownloadsDOMHandler::RemoveDownlo
   IdSet ids;
 
   for (auto* download : to_remove) {
-    if (download->IsDangerous()) {
-      // Don't allow users to revive dangerous downloads; just nuke 'em.
-      download->Remove();
-      continue;
-    }
-
     DownloadItemModel item_model(download);
     if (!item_model.ShouldShowInShelf() ||
         download->GetState() == content::DownloadItem::IN_PROGRESS) {
@@ -381,33 +346,6 @@ void MdDownloadsDOMHandler::FinalizeRemo
   }
 }
 
-void MdDownloadsDOMHandler::ShowDangerPrompt(
-    content::DownloadItem* dangerous_item) {
-  DownloadDangerPrompt* danger_prompt = DownloadDangerPrompt::Create(
-      dangerous_item,
-      GetWebUIWebContents(),
-      false,
-      base::Bind(&MdDownloadsDOMHandler::DangerPromptDone,
-                 weak_ptr_factory_.GetWeakPtr(), dangerous_item->GetId()));
-  // danger_prompt will delete itself.
-  DCHECK(danger_prompt);
-}
-
-void MdDownloadsDOMHandler::DangerPromptDone(
-    int download_id, DownloadDangerPrompt::Action action) {
-  if (action != DownloadDangerPrompt::ACCEPT)
-    return;
-  content::DownloadItem* item = NULL;
-  if (GetMainNotifierManager())
-    item = GetMainNotifierManager()->GetDownload(download_id);
-  if (!item && GetOriginalNotifierManager())
-    item = GetOriginalNotifierManager()->GetDownload(download_id);
-  if (!item || item->IsDone())
-    return;
-  CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_SAVE_DANGEROUS);
-  item->ValidateDangerousDownload();
-}
-
 bool MdDownloadsDOMHandler::IsDeletingHistoryAllowed() {
   content::DownloadManager* manager = GetMainNotifierManager();
   return manager &&
--- a/chrome/browser/extensions/api/downloads/downloads_api.cc
+++ b/chrome/browser/extensions/api/downloads/downloads_api.cc
@@ -39,7 +39,6 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/download/download_core_service.h"
 #include "chrome/browser/download/download_core_service_factory.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_file_icon_extractor.h"
 #include "chrome/browser/download/download_prefs.h"
 #include "chrome/browser/download/download_query.h"
@@ -1305,9 +1304,6 @@ DownloadsAcceptDangerFunction::Downloads
 
 DownloadsAcceptDangerFunction::~DownloadsAcceptDangerFunction() {}
 
-DownloadsAcceptDangerFunction::OnPromptCreatedCallback*
-    DownloadsAcceptDangerFunction::on_prompt_created_ = NULL;
-
 bool DownloadsAcceptDangerFunction::RunAsync() {
   std::unique_ptr<downloads::AcceptDanger::Params> params(
       downloads::AcceptDanger::Params::Create(*args_));
@@ -1343,40 +1339,7 @@ void DownloadsAcceptDangerFunction::Prom
     return;
   }
   RecordApiFunctions(DOWNLOADS_FUNCTION_ACCEPT_DANGER);
-  // DownloadDangerPrompt displays a modal dialog using native widgets that the
-  // user must either accept or cancel. It cannot be scripted.
-  DownloadDangerPrompt* prompt = DownloadDangerPrompt::Create(
-      download_item,
-      web_contents,
-      true,
-      base::Bind(&DownloadsAcceptDangerFunction::DangerPromptCallback,
-                 this, download_id));
-  // DownloadDangerPrompt deletes itself
-  if (on_prompt_created_ && !on_prompt_created_->is_null())
-    on_prompt_created_->Run(prompt);
-  // Function finishes in DangerPromptCallback().
-}
-
-void DownloadsAcceptDangerFunction::DangerPromptCallback(
-    int download_id, DownloadDangerPrompt::Action action) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DownloadItem* download_item =
-      GetDownload(browser_context(), include_incognito(), download_id);
-  if (InvalidId(download_item, &error_) ||
-      Fault(download_item->GetState() != DownloadItem::IN_PROGRESS,
-            errors::kNotInProgress, &error_))
-    return;
-  switch (action) {
-    case DownloadDangerPrompt::ACCEPT:
-      download_item->ValidateDangerousDownload();
-      break;
-    case DownloadDangerPrompt::CANCEL:
-      download_item->Remove();
-      break;
-    case DownloadDangerPrompt::DISMISS:
-      break;
-  }
-  SendResponse(error_.empty());
+  download_item->ValidateDangerousDownload();
 }
 
 DownloadsShowFunction::DownloadsShowFunction() {}
--- a/chrome/browser/extensions/api/downloads/downloads_api.h
+++ b/chrome/browser/extensions/api/downloads/downloads_api.h
@@ -13,7 +13,6 @@
 #include "base/macros.h"
 #include "base/scoped_observer.h"
 #include "base/time/time.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_path_reservation_tracker.h"
 #include "chrome/browser/extensions/chrome_extension_function.h"
 #include "chrome/common/extensions/api/downloads.h"
@@ -188,25 +187,16 @@ class DownloadsRemoveFileFunction : publ
 
 class DownloadsAcceptDangerFunction : public ChromeAsyncExtensionFunction {
  public:
-  typedef base::Callback<void(DownloadDangerPrompt*)> OnPromptCreatedCallback;
-  static void OnPromptCreatedForTesting(
-      OnPromptCreatedCallback* callback) {
-    on_prompt_created_ = callback;
-  }
-
   DECLARE_EXTENSION_FUNCTION("downloads.acceptDanger", DOWNLOADS_ACCEPTDANGER)
   DownloadsAcceptDangerFunction();
   bool RunAsync() override;
 
  protected:
   ~DownloadsAcceptDangerFunction() override;
-  void DangerPromptCallback(int download_id,
-                            DownloadDangerPrompt::Action action);
 
  private:
   void PromptOrWait(int download_id, int retries);
 
-  static OnPromptCreatedCallback* on_prompt_created_;
   DISALLOW_COPY_AND_ASSIGN(DownloadsAcceptDangerFunction);
 };
 
--- a/chrome/browser/download/download_prefs.cc
+++ b/chrome/browser/download/download_prefs.cc
@@ -186,14 +186,7 @@ DownloadPrefs::DownloadPrefs(Profile* pr
         base::FilePath::StringType(1, base::FilePath::kExtensionSeparator) +
         extension);
 
-    // Note that the list of file types that are not allowed to open
-    // automatically can change in the future. When the list is tightened, it is
-    // expected that some entries in the users' auto open list will get dropped
-    // permanently as a result.
-    if (FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
-            filename_with_extension)) {
-      auto_open_.insert(extension);
-    }
+    auto_open_.insert(extension);
   }
 }
 
@@ -329,10 +322,6 @@ bool DownloadPrefs::IsAutoOpenEnabledBas
 bool DownloadPrefs::EnableAutoOpenBasedOnExtension(
     const base::FilePath& file_name) {
   base::FilePath::StringType extension = file_name.Extension();
-  if (!FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
-          file_name)) {
-    return false;
-  }
 
   DCHECK(extension[0] == base::FilePath::kExtensionSeparator);
   extension.erase(0, 1);
--- a/chrome/browser/component_updater/file_type_policies_component_installer.cc
+++ b/chrome/browser/component_updater/file_type_policies_component_installer.cc
@@ -36,20 +36,6 @@ const uint8_t kPublicKeySHA256[32] = {
 const char kFileTypePoliciesManifestName[] = "File Type Policies";
 
 void LoadFileTypesFromDisk(const base::FilePath& pb_path) {
-  if (pb_path.empty())
-    return;
-
-  VLOG(1) << "Reading Download File Types from file: " << pb_path.value();
-  std::string binary_pb;
-  if (!base::ReadFileToString(pb_path, &binary_pb)) {
-    // The file won't exist on new installations, so this is not always an
-    // error.
-    VLOG(1) << "Failed reading from " << pb_path.value();
-    return;
-  }
-
-  safe_browsing::FileTypePolicies::GetInstance()->PopulateFromDynamicUpdate(
-      binary_pb);
 }
 
 }  // namespace
--- a/chrome/browser/download/download_target_determiner.cc
+++ b/chrome/browser/download/download_target_determiner.cc
@@ -880,29 +880,7 @@ DownloadFileType::DangerLevel DownloadTa
       download_->HasUserGesture())
     return DownloadFileType::NOT_DANGEROUS;
 
-  DownloadFileType::DangerLevel danger_level =
-      safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
-          virtual_path_.BaseName());
-
-  // A danger level of ALLOW_ON_USER_GESTURE is used to label potentially
-  // dangerous file types that have a high frequency of legitimate use. We would
-  // like to avoid prompting for the legitimate cases as much as possible. To
-  // that end, we consider a download to be legitimate if one of the following
-  // is true, and avoid prompting:
-  //
-  // * The user navigated to the download URL via the omnibox (either by typing
-  //   the URL, pasting it, or using search).
-  //
-  // * The navigation that initiated the download has a user gesture associated
-  //   with it AND the user the user is familiar with the referring origin. A
-  //   user is considered familiar with a referring origin if a visit for a page
-  //   from the same origin was recorded on the previous day or earlier.
-  if (danger_level == DownloadFileType::ALLOW_ON_USER_GESTURE &&
-      ((download_->GetTransitionType() &
-        ui::PAGE_TRANSITION_FROM_ADDRESS_BAR) != 0 ||
-       (download_->HasUserGesture() && visits == VISITED_REFERRER)))
-    return DownloadFileType::NOT_DANGEROUS;
-  return danger_level;
+  return DownloadFileType::NOT_DANGEROUS;
 }
 
 void DownloadTargetDeterminer::OnDownloadDestroyed(
--- a/chrome/browser/permissions/permission_uma_util.cc
+++ b/chrome/browser/permissions/permission_uma_util.cc
@@ -687,8 +687,6 @@ void PermissionUmaUtil::RecordPermission
         PermissionPersistDecision::UNSPECIFIED,
         autoblocker->GetDismissCount(requesting_origin, permission),
         autoblocker->GetIgnoreCount(requesting_origin, permission));
-    g_browser_process->safe_browsing_service()
-        ->ui_manager()->ReportPermissionAction(report_info);
   }
 
   bool secure_origin = content::IsOriginSecure(requesting_origin);
--- a/chrome/browser/download/download_commands.cc
+++ b/chrome/browser/download/download_commands.cc
@@ -187,9 +187,6 @@ bool DownloadCommands::IsCommandEnabled(
       // filename. Don't base an "Always open" decision based on it. Also
       // exclude extensions.
       return download_item_->CanOpenDownload() &&
-             safe_browsing::FileTypePolicies::GetInstance()
-                 ->IsAllowedToOpenAutomatically(
-                     download_item_->GetTargetFilePath()) &&
              !download_crx_util::IsExtensionDownload(*download_item_);
     case CANCEL:
       return !download_item_->IsDone();
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3204,8 +3204,6 @@ split_static_library("browser") {
       "download/download_commands.h",
       "download/download_crx_util.cc",
       "download/download_crx_util.h",
-      "download/download_danger_prompt.cc",
-      "download/download_danger_prompt.h",
       "download/download_dir_policy_handler.cc",
       "download/download_dir_policy_handler.h",
       "download/download_shelf.cc",
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -1439,7 +1439,6 @@ split_static_library("ui") {
       "views/cookie_info_view.h",
       "views/device_chooser_content_view.cc",
       "views/device_chooser_content_view.h",
-      "views/download/download_danger_prompt_views.cc",
       "views/elevation_icon_setter.cc",
       "views/elevation_icon_setter.h",
       "views/exclusive_access_bubble_views.cc",
@@ -2675,7 +2674,6 @@ split_static_library("ui") {
         "cocoa/dialog_text_field_editor.mm",
         "cocoa/download/background_theme.h",
         "cocoa/download/background_theme.mm",
-        "cocoa/download/download_danger_prompt_impl.cc",
         "cocoa/download/download_item_button.h",
         "cocoa/download/download_item_button.mm",
         "cocoa/download/download_item_cell.h",
--- a/chrome/browser/ssl/security_state_tab_helper.cc
+++ b/chrome/browser/ssl/security_state_tab_helper.cc
@@ -172,56 +172,6 @@ bool SecurityStateTabHelper::UsedPolicyI
 
 security_state::MaliciousContentStatus
 SecurityStateTabHelper::GetMaliciousContentStatus() const {
-  content::NavigationEntry* entry =
-      web_contents()->GetController().GetVisibleEntry();
-  if (!entry)
-    return security_state::MALICIOUS_CONTENT_STATUS_NONE;
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (!sb_service)
-    return security_state::MALICIOUS_CONTENT_STATUS_NONE;
-  scoped_refptr<SafeBrowsingUIManager> sb_ui_manager = sb_service->ui_manager();
-  safe_browsing::SBThreatType threat_type;
-  if (sb_ui_manager->IsUrlWhitelistedOrPendingForWebContents(
-          entry->GetURL(), false, entry, web_contents(), false, &threat_type)) {
-    switch (threat_type) {
-      case safe_browsing::SB_THREAT_TYPE_UNUSED:
-      case safe_browsing::SB_THREAT_TYPE_SAFE:
-        break;
-      case safe_browsing::SB_THREAT_TYPE_URL_PHISHING:
-      case safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_PHISHING:
-      case safe_browsing::SB_THREAT_TYPE_URL_PASSWORD_PROTECTION_PHISHING:
-        return security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING;
-      case safe_browsing::SB_THREAT_TYPE_URL_MALWARE:
-      case safe_browsing::SB_THREAT_TYPE_URL_CLIENT_SIDE_MALWARE:
-        return security_state::MALICIOUS_CONTENT_STATUS_MALWARE;
-      case safe_browsing::SB_THREAT_TYPE_URL_UNWANTED:
-        return security_state::MALICIOUS_CONTENT_STATUS_UNWANTED_SOFTWARE;
-      case safe_browsing::SB_THREAT_TYPE_PASSWORD_REUSE:
-#if defined(SAFE_BROWSING_DB_LOCAL)
-        if (base::FeatureList::IsEnabled(
-                safe_browsing::kGoogleBrandedPhishingWarning) &&
-            sb_service->GetPasswordProtectionService(
-                Profile::FromBrowserContext(
-                    web_contents()->GetBrowserContext()))) {
-          return security_state::MALICIOUS_CONTENT_STATUS_PASSWORD_REUSE;
-        }
-        break;
-#endif
-      case safe_browsing::SB_THREAT_TYPE_URL_BINARY_MALWARE:
-      case safe_browsing::SB_THREAT_TYPE_EXTENSION:
-      case safe_browsing::SB_THREAT_TYPE_BLACKLISTED_RESOURCE:
-      case safe_browsing::SB_THREAT_TYPE_API_ABUSE:
-      case safe_browsing::SB_THREAT_TYPE_SUBRESOURCE_FILTER:
-      case safe_browsing::SB_THREAT_TYPE_CSD_WHITELIST:
-      case safe_browsing::SB_THREAT_TYPE_AD_SAMPLE:
-        // These threat types are not currently associated with
-        // interstitials, and thus resources with these threat types are
-        // not ever whitelisted or pending whitelisting.
-        NOTREACHED();
-        break;
-    }
-  }
   return security_state::MALICIOUS_CONTENT_STATUS_NONE;
 }
 
--- a/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
+++ b/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
@@ -703,40 +703,6 @@ void ChromeBrowsingDataRemoverDelegate::
             CONTENT_SETTINGS_TYPE_CLIENT_HINTS, base::Time(),
             base::Bind(&WebsiteSettingsFilterAdapter, filter));
 
-    // Clear the safebrowsing cookies only if time period is for "all time".  It
-    // doesn't make sense to apply the time period of deleting in the last X
-    // hours/days to the safebrowsing cookies since they aren't the result of
-    // any user action.
-    if (delete_begin_ == base::Time()) {
-      safe_browsing::SafeBrowsingService* sb_service =
-          g_browser_process->safe_browsing_service();
-      if (sb_service) {
-        scoped_refptr<net::URLRequestContextGetter> sb_context =
-            sb_service->url_request_context();
-        ++clear_cookies_count_;
-        if (filter_builder.IsEmptyBlacklist()) {
-          BrowserThread::PostTask(
-              BrowserThread::IO, FROM_HERE,
-              base::BindOnce(
-                  &ClearCookiesOnIOThread, delete_begin_, delete_end_,
-                  base::RetainedRef(std::move(sb_context)),
-                  UIThreadTrampoline(base::Bind(
-                      &ChromeBrowsingDataRemoverDelegate::OnClearedCookies,
-                      weak_ptr_factory_.GetWeakPtr()))));
-        } else {
-          BrowserThread::PostTask(
-              BrowserThread::IO, FROM_HERE,
-              base::BindOnce(
-                  &ClearCookiesWithPredicateOnIOThread, delete_begin_,
-                  delete_end_, filter_builder.BuildCookieFilter(),
-                  base::RetainedRef(std::move(sb_context)),
-                  UIThreadTrampoline(base::Bind(
-                      &ChromeBrowsingDataRemoverDelegate::OnClearedCookies,
-                      weak_ptr_factory_.GetWeakPtr()))));
-        }
-      }
-    }
-
     MediaDeviceIDSalt::Reset(profile_->GetPrefs());
   }
 
--- a/chrome/browser/notifications/platform_notification_service_impl.cc
+++ b/chrome/browser/notifications/platform_notification_service_impl.cc
@@ -26,8 +26,6 @@
 #include "chrome/browser/profiles/profile_attributes_storage.h"
 #include "chrome/browser/profiles/profile_io_data.h"
 #include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/browser/safe_browsing/ping_manager.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/features.h"
@@ -94,18 +92,6 @@ void CancelNotification(const std::strin
                  notification_id));
 }
 
-void ReportNotificationImageOnIOThread(
-    scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service,
-    Profile* profile,
-    const GURL& origin,
-    const SkBitmap& image) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  if (!safe_browsing_service || !safe_browsing_service->enabled())
-    return;
-  safe_browsing_service->ping_manager()->ReportNotificationImage(
-      profile, safe_browsing_service->database_manager(), origin, image);
-}
-
 }  // namespace
 
 // static
@@ -461,12 +447,6 @@ Notification PlatformNotificationService
     notification.set_image(
         gfx::Image::CreateFrom1xBitmap(notification_resources.image));
     // n.b. this should only be posted once per notification.
-    BrowserThread::PostTask(
-        BrowserThread::IO, FROM_HERE,
-        base::BindOnce(
-            &ReportNotificationImageOnIOThread,
-            make_scoped_refptr(g_browser_process->safe_browsing_service()),
-            profile, origin, notification_resources.image));
   }
 
   // Badges are only supported on Android, primarily because it's the only
--- a/chrome/browser/permissions/permission_blacklist_client.cc
+++ b/chrome/browser/permissions/permission_blacklist_client.cc
@@ -57,50 +57,11 @@ PermissionBlacklistClient::~PermissionBl
 void PermissionBlacklistClient::StartCheck(const GURL& request_origin) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
 
-  // Start the timer to interrupt into the client callback method with an
-  // empty response if Safe Browsing times out.
-  safe_browsing::ThreatMetadata empty_metadata;
-  timer_ = base::MakeUnique<base::OneShotTimer>();
-  elapsed_timer_.reset(new base::ElapsedTimer());
-  timer_->Start(
-      FROM_HERE, base::TimeDelta::FromMilliseconds(timeout_),
-      base::Bind(&PermissionBlacklistClient::OnCheckApiBlacklistUrlResult, this,
-                 request_origin, empty_metadata));
-  // If CheckApiBlacklistUrl returns true, no asynchronous call to |this| will
-  // be made, so just directly call through to OnCheckApiBlacklistUrlResult.
-  if (db_manager_->CheckApiBlacklistUrl(request_origin, this))
-    OnCheckApiBlacklistUrlResult(request_origin, empty_metadata);
-}
-
-void PermissionBlacklistClient::OnCheckApiBlacklistUrlResult(
-    const GURL& url,
-    const safe_browsing::ThreatMetadata& metadata) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-  base::TimeDelta response_time = elapsed_timer_->Elapsed();
-  SafeBrowsingResponse response = SafeBrowsingResponse::NOT_BLACKLISTED;
-
-  if (timer_->IsRunning()) {
-    timer_->Stop();
-  } else {
-    db_manager_->CancelApiCheck(this);
-    response = SafeBrowsingResponse::TIMEOUT;
-  }
-
-  timer_.reset(nullptr);
-  bool permission_blocked =
-      metadata.api_permissions.find(
-          PermissionUtil::ConvertContentSettingsTypeToSafeBrowsingName(
-              content_settings_type_)) != metadata.api_permissions.end();
-  if (permission_blocked)
-    response = SafeBrowsingResponse::BLACKLISTED;
-
-  PermissionUmaUtil::RecordSafeBrowsingResponse(response_time, response);
   content::BrowserThread::PostTask(
       content::BrowserThread::UI, FROM_HERE,
       base::BindOnce(
           &PermissionBlacklistClient::EvaluateBlacklistResultOnUiThread, this,
-          permission_blocked));
+          false));
 }
 
 void PermissionBlacklistClient::EvaluateBlacklistResultOnUiThread(
--- a/chrome/browser/metrics/chrome_metrics_service_client.cc
+++ b/chrome/browser/metrics/chrome_metrics_service_client.cc
@@ -44,7 +44,6 @@
 #include "chrome/browser/metrics/sampling_metrics_provider.h"
 #include "chrome/browser/metrics/subprocess_metrics_provider.h"
 #include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/browser/safe_browsing/certificate_reporting_metrics_provider.h"
 #include "chrome/browser/sync/chrome_sync_client.h"
 #include "chrome/browser/sync/profile_sync_service_factory.h"
 #include "chrome/browser/translate/translate_ranker_metrics_provider.h"
@@ -668,10 +667,6 @@ void ChromeMetricsServiceClient::Registe
       std::unique_ptr<metrics::MetricsProvider>(
           new HttpsEngagementMetricsProvider()));
 
-  metrics_service_->RegisterMetricsProvider(
-      std::unique_ptr<metrics::MetricsProvider>(
-          new CertificateReportingMetricsProvider()));
-
 #if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   metrics_service_->RegisterMetricsProvider(
       std::unique_ptr<metrics::MetricsProvider>(new UpgradeMetricsProvider()));
--- a/chrome/browser/permissions/permission_blacklist_client.h
+++ b/chrome/browser/permissions/permission_blacklist_client.h
@@ -59,11 +59,6 @@ class PermissionBlacklistClient
 
   void StartCheck(const GURL& request_origin);
 
-  // SafeBrowsingDatabaseManager::Client implementation.
-  void OnCheckApiBlacklistUrlResult(
-      const GURL& url,
-      const safe_browsing::ThreatMetadata& metadata) override;
-
   void EvaluateBlacklistResultOnUiThread(bool response);
 
   // WebContentsObserver implementation. Sets a flag so that when the database
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -207,7 +207,6 @@ EnsureBrowserContextKeyedServiceFactorie
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
-  CertificateReportingServiceFactory::GetInstance();
 #if defined(OS_ANDROID)
   chrome::android::DataUseUITabModelFactory::GetInstance();
 #endif
--- a/chrome/browser/ssl/captive_portal_blocking_page.cc
+++ b/chrome/browser/ssl/captive_portal_blocking_page.cc
@@ -77,13 +77,6 @@ CaptivePortalBlockingPage::CaptivePortal
       callback_(callback) {
   DCHECK(login_url_.is_valid());
 
-  if (ssl_cert_reporter) {
-    cert_report_helper_.reset(new CertReportHelper(
-        std::move(ssl_cert_reporter), web_contents, request_url, ssl_info,
-        certificate_reporting::ErrorReport::INTERSTITIAL_CAPTIVE_PORTAL, false,
-        base::Time::Now(), nullptr));
-  }
-
   captive_portal::CaptivePortalMetrics::LogCaptivePortalBlockingPageEvent(
       captive_portal::CaptivePortalMetrics::SHOW_ALL);
 }
@@ -194,10 +187,7 @@ void CaptivePortalBlockingPage::Populate
   load_time_data->SetString("explanationParagraph", base::string16());
   load_time_data->SetString("finalParagraph", base::string16());
 
-  if (cert_report_helper_)
-    cert_report_helper_->PopulateExtendedReportingOption(load_time_data);
-  else
-    load_time_data->SetBoolean(security_interstitials::kDisplayCheckBox, false);
+  load_time_data->SetBoolean(security_interstitials::kDisplayCheckBox, false);
 }
 
 void CaptivePortalBlockingPage::CommandReceived(const std::string& command) {
@@ -258,12 +248,6 @@ void CaptivePortalBlockingPage::OnProcee
 
 void CaptivePortalBlockingPage::OnDontProceed() {
   UpdateMetricsAfterSecurityInterstitial();
-  if (cert_report_helper_) {
-    // Finish collecting information about invalid certificates, if the
-    // user opted in to.
-    cert_report_helper_->FinishCertCollection(
-        certificate_reporting::ErrorReport::USER_DID_NOT_PROCEED);
-  }
 
   // Need to explicity deny the certificate via the callback, otherwise memory
   // is leaked.
--- a/chrome/browser/ssl/cert_report_helper.cc
+++ b/chrome/browser/ssl/cert_report_helper.cc
@@ -153,8 +153,6 @@ void CertReportHelper::FinishCertCollect
     LOG(ERROR) << "Failed to serialize certificate report.";
     return;
   }
-
-  ssl_cert_reporter_->ReportInvalidCertificateChain(serialized_report);
 }
 
 void CertReportHelper::SetSSLCertReporterForTesting(
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -267,11 +267,6 @@ void TabHelpers::AttachTabHelpers(WebCon
                         new ChromePDFWebContentsHelperClient()));
   PluginObserver::CreateForWebContents(web_contents);
   SadTabHelper::CreateForWebContents(web_contents);
-  safe_browsing::SafeBrowsingTabObserver::CreateForWebContents(web_contents);
-  safe_browsing::SafeBrowsingNavigationObserver::MaybeCreateForWebContents(
-      web_contents);
-  safe_browsing::TriggerCreator::MaybeCreateTriggersForWebContents(
-      profile, web_contents);
   TabContentsSyncedTabDelegate::CreateForWebContents(web_contents);
   TabDialogs::CreateForWebContents(web_contents);
   ThumbnailTabHelper::CreateForWebContents(web_contents);
--- a/chrome/browser/permissions/permission_decision_auto_blocker.cc
+++ b/chrome/browser/permissions/permission_decision_auto_blocker.cc
@@ -16,7 +16,6 @@
 #include "chrome/browser/permissions/permission_util.h"
 #include "chrome/browser/profiles/incognito_helpers.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/common/chrome_features.h"
 #include "components/keyed_service/content/browser_context_dependency_manager.h"
 #include "components/safe_browsing_db/database_manager.h"
@@ -435,10 +434,6 @@ PermissionDecisionAutoBlocker::Permissio
       db_manager_(nullptr),
       safe_browsing_timeout_(kCheckUrlTimeoutMs),
       clock_(new base::DefaultClock()) {
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (sb_service)
-    db_manager_ = sb_service->database_manager();
 }
 
 PermissionDecisionAutoBlocker::~PermissionDecisionAutoBlocker() {}
--- a/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc
+++ b/chrome/browser/subresource_filter/chrome_subresource_filter_client.cc
@@ -44,14 +44,7 @@ DEFINE_WEB_CONTENTS_USER_DATA_KEY(Chrome
 namespace {
 
 scoped_refptr<safe_browsing::SafeBrowsingDatabaseManager> GetDatabaseManager() {
-  safe_browsing::SafeBrowsingService* safe_browsing_service =
-      g_browser_process->safe_browsing_service();
-  bool has_supported_manager =
-      safe_browsing_service &&
-      safe_browsing_service->database_manager()->IsSupported() &&
-      safe_browsing_service->database_manager()->CanCheckSubresourceFilter();
-  return has_supported_manager ? safe_browsing_service->database_manager()
-                               : nullptr;
+  return nullptr;
 }
 
 }  // namespace
@@ -73,21 +66,6 @@ ChromeSubresourceFilterClient::~ChromeSu
 void ChromeSubresourceFilterClient::MaybeAppendNavigationThrottles(
     content::NavigationHandle* navigation_handle,
     std::vector<std::unique_ptr<content::NavigationThrottle>>* throttles) {
-  if (navigation_handle->IsInMainFrame()) {
-    throttles->push_back(
-        base::MakeUnique<subresource_filter::
-                             SubresourceFilterSafeBrowsingActivationThrottle>(
-            navigation_handle, this,
-            content::BrowserThread::GetTaskRunnerForThread(
-                content::BrowserThread::IO),
-            GetDatabaseManager()));
-  }
-
-  auto* driver_factory =
-      subresource_filter::ContentSubresourceFilterDriverFactory::
-          FromWebContents(navigation_handle->GetWebContents());
-  driver_factory->throttle_manager()->MaybeAppendNavigationThrottles(
-      navigation_handle, throttles);
 }
 
 void ChromeSubresourceFilterClient::OnReloadRequested() {
--- a/chrome/browser/extensions/webstore_inline_installer.cc
+++ b/chrome/browser/extensions/webstore_inline_installer.cc
@@ -115,85 +115,10 @@ bool WebstoreInlineInstaller::IsRequesto
 }
 
 bool WebstoreInlineInstaller::SafeBrowsingNavigationEventsEnabled() const {
-  return SafeBrowsingNavigationObserverManager::IsEnabledAndReady(profile());
+  return false;
 }
 
 std::string WebstoreInlineInstaller::GetJsonPostData() {
-  // web_contents() might return null during tab destruction. This object would
-  // also be destroyed shortly thereafter but check to be on the safe side.
-  if (!web_contents())
-    return std::string();
-
-  // Report extra data only when SafeBrowsing is enabled for the current
-  // profile.
-  if (!profile()->GetPrefs()->GetBoolean(prefs::kSafeBrowsingEnabled))
-    return std::string();
-
-  auto redirect_chain = base::MakeUnique<base::ListValue>();
-
-  if (SafeBrowsingNavigationEventsEnabled()) {
-    // If we have it, use the new referrer checker.
-    safe_browsing::SafeBrowsingService* safe_browsing_service =
-        g_browser_process->safe_browsing_service();
-    // May be null in some tests.
-    if (!safe_browsing_service)
-      return std::string();
-
-    scoped_refptr<SafeBrowsingNavigationObserverManager>
-        navigation_observer_manager =
-            safe_browsing_service->navigation_observer_manager();
-    // This may be null if the navigation observer manager feature is
-    // disabled by experiment.
-    if (!navigation_observer_manager)
-      return std::string();
-
-    ReferrerChain referrer_chain;
-    SafeBrowsingNavigationObserverManager::AttributionResult result =
-        navigation_observer_manager->IdentifyReferrerChainByWebContents(
-            web_contents(), kExtensionReferrerUserGestureLimit,
-            &referrer_chain);
-    if (result !=
-        SafeBrowsingNavigationObserverManager::NAVIGATION_EVENT_NOT_FOUND) {
-      // For now the CWS post data is JSON encoded. Consider moving it to a
-      // proto.
-      for (const auto& referrer_chain_entry : referrer_chain) {
-        // Referrer chain entries are a list of URLs in reverse chronological
-        // order, so the final URL is the last thing in the list and the initial
-        // landing page is the first thing in the list.
-        // Furthermore each entry may contain a series of server redirects
-        // stored in the same order.
-        redirect_chain->AppendString(referrer_chain_entry.url());
-        for (const auto& server_side_redirect :
-             referrer_chain_entry.server_redirect_chain()) {
-          redirect_chain->AppendString(server_side_redirect.url());
-        }
-      }
-    }
-  } else {
-    content::NavigationController& navigation_controller =
-        web_contents()->GetController();
-    content::NavigationEntry* navigation_entry =
-        navigation_controller.GetLastCommittedEntry();
-    if (navigation_entry) {
-      const std::vector<GURL>& redirect_urls =
-          navigation_entry->GetRedirectChain();
-      for (const GURL& url : redirect_urls) {
-        redirect_chain->AppendString(url.spec());
-      }
-    }
-  }
-
-  if (!redirect_chain->empty()) {
-    base::DictionaryValue dictionary;
-    dictionary.SetString("id", id());
-    dictionary.SetString("referrer", requestor_url_.spec());
-    dictionary.Set("redirect_chain", std::move(redirect_chain));
-
-    std::string json;
-    base::JSONWriter::Write(dictionary, &json);
-    return json;
-  }
-
   return std::string();
 }
 
--- a/chrome/browser/safe_browsing/BUILD.gn
+++ b/chrome/browser/safe_browsing/BUILD.gn
@@ -12,6 +12,11 @@ proto_library("chunk_proto") {
 }
 
 static_library("safe_browsing") {
+  deps = [
+    "//components/safe_browsing:csd_proto",
+  ]
+
+  if (false) {
   sources = [
     "chrome_cleaner/chrome_cleaner_controller_impl_win.cc",
     "chrome_cleaner/chrome_cleaner_controller_impl_win.h",
@@ -69,6 +74,7 @@ static_library("safe_browsing") {
       "settings_reset_prompt/settings_reset_prompt_util_win.h",
     ]
   }
+  }
 
   if (safe_browsing_mode != 0) {
     # "Safe Browsing Basic" files used for safe browsing in full mode
--- a/chrome/browser/net/system_network_context_manager.cc
+++ b/chrome/browser/net/system_network_context_manager.cc
@@ -43,17 +43,11 @@ content::mojom::NetworkContextParamsPtr
 // Called on IOThread to disable QUIC for HttpNetworkSessions not using the
 // network service. Note that re-enabling QUIC dynamically is not supported for
 // simpliciy and requires a browser restart.
-void DisableQuicOnIOThread(
-    IOThread* io_thread,
-    safe_browsing::SafeBrowsingService* safe_browsing_service) {
+void DisableQuicOnIOThread(IOThread* io_thread) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
 
   // Disable QUIC for HttpNetworkSessions using IOThread's NetworkService.
   io_thread->DisableQuic();
-
-  // Safebrowsing isn't yet using the IOThread's NetworkService, so must be
-  // handled separately.
-  safe_browsing_service->DisableQuicOnIOThread();
 }
 
 }  // namespace
@@ -116,11 +110,7 @@ void SystemNetworkContextManager::Disabl
   if (!io_thread)
     return;
 
-  safe_browsing::SafeBrowsingService* safe_browsing_service =
-      g_browser_process->safe_browsing_service();
-
   content::BrowserThread::PostTask(
       content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&DisableQuicOnIOThread, io_thread,
-                     base::Unretained(safe_browsing_service)));
+      base::BindOnce(&DisableQuicOnIOThread, io_thread));
 }
--- a/chrome/browser/ui/webui/settings/change_password_handler.cc
+++ b/chrome/browser/ui/webui/settings/change_password_handler.cc
@@ -17,10 +17,6 @@ namespace settings {
 
 ChangePasswordHandler::ChangePasswordHandler(Profile* profile)
     : profile_(profile), service_(nullptr) {
-  if (g_browser_process && g_browser_process->safe_browsing_service()) {
-    service_ = g_browser_process->safe_browsing_service()
-                   ->GetPasswordProtectionService(profile_);
-  }
 }
 
 ChangePasswordHandler::~ChangePasswordHandler() {}
--- a/chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc
+++ b/chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc
@@ -391,9 +391,8 @@ void AddBluetoothStrings(content::WebUID
 #endif
 
 void AddChangePasswordStrings(content::WebUIDataSource* html_source) {
-#if defined(SAFE_BROWSING_DB_LOCAL)
-  bool show_softer_warning =
-      safe_browsing::PasswordProtectionService::ShouldShowSofterWarning();
+#if 1
+  bool show_softer_warning = true;
 
   auto title_string_id = show_softer_warning
                              ? IDS_SETTINGS_CHANGE_PASSWORD_TITLE_SOFTER
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -58,7 +58,6 @@
 #include "chrome/renderer/prerender/prerender_dispatcher.h"
 #include "chrome/renderer/prerender/prerender_helper.h"
 #include "chrome/renderer/prerender/prerenderer_client.h"
-#include "chrome/renderer/safe_browsing/phishing_classifier_delegate.h"
 #include "chrome/renderer/searchbox/search_bouncer.h"
 #include "chrome/renderer/searchbox/searchbox.h"
 #include "chrome/renderer/searchbox/searchbox_extension.h"
@@ -80,9 +79,6 @@
 #include "components/network_hints/renderer/prescient_networking_dispatcher.h"
 #include "components/password_manager/content/renderer/credential_manager_client.h"
 #include "components/pdf/renderer/pepper_pdf_host.h"
-#include "components/safe_browsing/renderer/renderer_url_loader_throttle.h"
-#include "components/safe_browsing/renderer/threat_dom_details.h"
-#include "components/safe_browsing/renderer/websocket_sb_handshake_throttle.h"
 #include "components/signin/core/common/profile_management_switches.h"
 #include "components/spellcheck/spellcheck_build_features.h"
 #include "components/startup_metric_utils/common/startup_metric.mojom.h"
@@ -442,9 +438,6 @@ void ChromeContentRendererClient::Render
     thread->AddObserver(spellcheck_.get());
   }
 #endif
-#if defined(FULL_SAFE_BROWSING)
-  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());
-#endif
   prerender_dispatcher_.reset(new prerender::PrerenderDispatcher());
   subresource_filter_ruleset_dealer_.reset(
       new subresource_filter::UnverifiedRulesetDealer());
@@ -557,10 +550,6 @@ void ChromeContentRendererClient::Render
   new nacl::NaClHelper(render_frame);
 #endif
 
-#if defined(FULL_SAFE_BROWSING)
-  safe_browsing::ThreatDOMDetails::Create(render_frame);
-#endif
-
 #if BUILDFLAG(ENABLE_PRINTING)
   new printing::PrintRenderFrameHelper(
       render_frame, base::MakeUnique<ChromePrintRenderFrameHelperDelegate>());
@@ -1268,16 +1257,6 @@ bool ChromeContentRendererClient::WillSe
     const blink::WebURL& url,
     std::vector<std::unique_ptr<content::URLLoaderThrottle>>* throttles,
     GURL* new_url) {
-  if (base::FeatureList::IsEnabled(features::kNetworkService)) {
-    InitSafeBrowsingIfNecessary();
-    RenderFrame* render_frame = content::RenderFrame::FromWebFrame(frame);
-    int render_frame_id =
-        render_frame ? render_frame->GetRoutingID() : MSG_ROUTING_NONE;
-    throttles->push_back(
-        base::MakeUnique<safe_browsing::RendererURLLoaderThrottle>(
-            safe_browsing_.get(), render_frame_id));
-  }
-
 // Check whether the request should be allowed. If not allowed, we reset the
 // URL to something invalid to prevent the request and cause an error.
 #if BUILDFLAG(ENABLE_EXTENSIONS)
@@ -1373,9 +1352,7 @@ bool ChromeContentRendererClient::IsExte
 
 std::unique_ptr<blink::WebSocketHandshakeThrottle>
 ChromeContentRendererClient::CreateWebSocketHandshakeThrottle() {
-  InitSafeBrowsingIfNecessary();
-  return base::MakeUnique<safe_browsing::WebSocketSBHandshakeThrottle>(
-      safe_browsing_.get());
+  return nullptr;
 }
 
 std::unique_ptr<blink::WebSpeechSynthesizer>
@@ -1663,10 +1640,3 @@ ChromeContentRendererClient::GetTaskSche
   return task_scheduler_util::
       GetRendererTaskSchedulerInitParamsFromCommandLine();
 }
-
-void ChromeContentRendererClient::InitSafeBrowsingIfNecessary() {
-  if (safe_browsing_)
-    return;
-  RenderThread::Get()->GetConnector()->BindInterface(
-      content::mojom::kBrowserServiceName, &safe_browsing_);
-}
--- a/chrome/renderer/chrome_content_renderer_client.h
+++ b/chrome/renderer/chrome_content_renderer_client.h
@@ -18,7 +18,6 @@
 #include "base/strings/string16.h"
 #include "chrome/renderer/media/chrome_key_systems_provider.h"
 #include "components/rappor/public/interfaces/rappor_recorder.mojom.h"
-#include "components/safe_browsing/common/safe_browsing.mojom.h"
 #include "components/spellcheck/spellcheck_build_features.h"
 #include "content/public/renderer/content_renderer_client.h"
 #include "extensions/features/features.h"
@@ -26,6 +25,7 @@
 #include "media/media_features.h"
 #include "ppapi/features/features.h"
 #include "printing/features/features.h"
+#include "third_party/WebKit/public/platform/WebSocketHandshakeThrottle.h"
 #include "v8/include/v8.h"
 
 #if defined (OS_CHROMEOS)
@@ -69,10 +69,6 @@ namespace prerender {
 class PrerenderDispatcher;
 }
 
-namespace safe_browsing {
-class PhishingClassifierFilter;
-}
-
 namespace subresource_filter {
 class UnverifiedRulesetDealer;
 }
@@ -238,9 +234,6 @@ class ChromeContentRendererClient : publ
   static GURL GetNaClContentHandlerURL(const std::string& actual_mime_type,
                                        const content::WebPluginInfo& plugin);
 
-  // Initialises |safe_browsing_| if it is not already initialised.
-  void InitSafeBrowsingIfNecessary();
-
   void GetNavigationErrorStringsInternal(
       content::RenderFrame* render_frame,
       const blink::WebURLRequest& failed_request,
@@ -272,12 +265,9 @@ class ChromeContentRendererClient : publ
 
   chrome::ChromeKeySystemsProvider key_systems_provider_;
 
-  safe_browsing::mojom::SafeBrowsingPtr safe_browsing_;
-
 #if BUILDFLAG(ENABLE_SPELLCHECK)
   std::unique_ptr<SpellCheck> spellcheck_;
 #endif
-  std::unique_ptr<safe_browsing::PhishingClassifierFilter> phishing_classifier_;
   std::unique_ptr<subresource_filter::UnverifiedRulesetDealer>
       subresource_filter_ruleset_dealer_;
   std::unique_ptr<prerender::PrerenderDispatcher> prerender_dispatcher_;
